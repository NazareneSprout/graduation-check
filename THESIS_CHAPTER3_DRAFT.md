# 논문 3장: 시스템 설계 및 구현

## Ⅲ. 시스템 설계 및 구현

### 3.1 시스템 아키텍처 설계

#### 3.1.1 전체 시스템 구조

본 연구에서 개발한 졸업요건 분석 시스템은 Android 네이티브 애플리케이션으로 구현되었으며, Firebase 기반의 서버리스 아키텍처를 채택하였다. 기존 연구들이 주로 웹 기반의 전통적인 클라이언트-서버 구조를 사용한 것과 달리, 본 시스템은 모바일 환경에 최적화된 4계층 아키텍처를 설계하였다.

시스템은 Presentation Layer, Business Logic Layer, Data Access Layer, External Services Layer로 구성되며, 각 계층은 명확히 분리되어 독립적인 개발과 유지보수가 가능하도록 설계하였다. Presentation Layer에서는 Fragment 기반의 화면 구성과 Material Design 3를 적용하여 일관된 사용자 경험을 제공한다. Business Logic Layer는 싱글톤 패턴으로 구현된 FirebaseDataManager를 중심으로 졸업요건 계산, 대체과목 매칭, 과목 추천 등의 핵심 로직을 처리한다. Data Access Layer에서는 3단계 캐싱 전략과 N+1 쿼리 최적화를 통해 성능을 극대화하였으며, External Services Layer에서는 Firebase Firestore, Storage, Authentication과 함께 Jsoup 라이브러리를 활용한 웹 스크래핑 기능을 제공한다.

이러한 계층 구조는 2장에서 소개한 선행 연구들과 비교할 때 다음과 같은 차별성을 갖는다. 첫째, 정적인 규칙 기반 검증 방식이 아닌 동적 규칙 로딩 및 실시간 업데이트가 가능한 구조를 채택하였다. 둘째, 단순 정보 조회 수준을 넘어 복잡한 비즈니스 로직을 클라이언트에서 직접 처리하는 하이브리드 구조를 구현하였다. 셋째, 서버리스 아키텍처를 통해 인프라 관리 부담을 최소화하고 확장성을 확보하였다.

#### 3.1.2 데이터베이스 설계

데이터베이스는 Firebase Firestore의 NoSQL 특성을 활용하여 유연한 스키마 구조로 설계하였다. 기존 시스템들이 관계형 데이터베이스의 고정된 스키마를 사용하여 학사 제도 변경 시 데이터베이스 마이그레이션이 필요했던 것과 달리, 본 시스템은 문서 기반 구조를 통해 학사 규정 변경을 즉시 반영할 수 있도록 하였다.

graduation_requirements 컬렉션은 "{학번}_{학부}_{트랙}" 형식의 문서 ID를 사용하여 각 학생 그룹별 졸업 요건을 관리한다. 각 문서는 studentId, department, track 등의 기본 정보와 함께 rules 맵을 포함하는데, 이 맵은 학기별, 카테고리별로 중첩된 구조를 가지고 있어 복잡한 졸업 요건 체계를 표현할 수 있다. categoryRequirements 맵에서는 각 카테고리의 필요 학점과 초과 학점 이월 규칙을 정의하며, replacementRules 배열에서는 대체과목 규칙을 관리한다.

users 컬렉션은 사용자별 개인 정보와 학습 이력을 저장한다. 각 사용자 문서는 email, studentInfo, completedCourses, savedResults 등의 필드를 포함하며, Firestore의 서브컬렉션 기능을 활용하여 대용량 데이터를 효율적으로 관리한다. 특히 savedResults 배열을 통해 사용자가 수행한 졸업요건 분석 결과를 저장하고 추후 조회할 수 있도록 하였다.

이러한 스키마 설계는 기존 관계형 데이터베이스 기반 시스템과 비교할 때, 학사 제도 변경에 대한 유연성과 확장성 측면에서 명확한 우위를 가진다. 또한 대체과목 규칙을 별도 필드로 관리함으로써 관리자가 웹 인터페이스 없이도 Firestore 콘솔에서 직접 규칙을 추가하거나 수정할 수 있는 편의성을 제공한다.

---

### 3.2 핵심 알고리즘 설계 및 구현

#### 3.2.1 대체과목 자동 매칭 알고리즘

대학의 학사 제도는 교육과정 개편에 따라 지속적으로 변화하며, 특정 과목이 폐지되고 새로운 과목으로 대체되는 경우가 빈번하게 발생한다. 예를 들어, 20학번 학생이 수강한 "2D융합디자인" 과목이 21학번부터 "디자인씽킹"으로 과목명이 변경되고 전공선택에서 전공필수로 분류가 변경되는 경우, 해당 학생의 졸업요건 분석 시 이를 자동으로 인식하고 적절한 카테고리로 인정해주어야 한다. 기존 시스템들은 이러한 대체 인정을 관리자가 수동으로 처리하거나, 학생이 직접 학과 사무실에 문의하여 확인해야 하는 불편함이 있었다.

본 연구에서는 규칙 기반 자동 매칭 알고리즘을 설계하여 이 문제를 해결하였다. 알고리즘의 핵심 원리는 다음과 같다. 먼저, 사용자가 수강한 과목 리스트와 시스템에 등록된 대체과목 규칙 리스트를 입력으로 받는다. 각 대체과목 규칙은 원본 과목명, 대체 과목명, 대체 카테고리, 그리고 적용 조건(학번 범위, 학기 범위 등)으로 구성된다. 알고리즘은 사용자의 수강 과목을 순회하면서 각 과목에 대해 매칭 가능한 대체과목 규칙이 있는지 검사한다. 규칙이 매칭되면 해당 규칙의 적용 조건을 검증하고, 조건을 만족하는 경우 대체 과목을 가상으로 생성하여 수강 과목 리스트에 추가한다.

여기서 "가상으로 생성"한다는 것은 원본 과목을 삭제하거나 수정하는 것이 아니라, 대체 과목을 추가로 생성하여 두 과목 모두를 유지한다는 의미이다. 이러한 접근법은 사용자의 실제 수강 이력을 보존하면서도 졸업요건 분석 시에는 대체 과목으로 인정할 수 있게 한다. 또한 하나의 과목에 여러 대체과목 규칙이 매칭될 수 있는 경우를 대비하여 First-Match Policy를 적용하였다. 즉, 첫 번째로 매칭된 규칙만 적용하고 나머지는 무시함으로써 중복 적용을 방지한다.

적용 조건 검증은 대체과목 규칙의 정확성을 보장하는 중요한 단계이다. 학번 범위 조건은 해당 대체 규칙이 적용되는 학생의 입학 연도 범위를 지정한다. 예를 들어, minStudentId가 20이고 maxStudentId가 23인 규칙은 20학번부터 23학번 학생에게만 적용된다. 학기 범위 조건은 선택적이며, 특정 학기에 수강한 과목에만 규칙을 적용해야 하는 경우에 사용된다.

구현 단계에서는 GraduationAnalysisResultActivity 클래스의 applyReplacementRules 메서드에서 이 알고리즘을 구현하였다. 메서드는 사용자의 수강 과목 리스트와 졸업 요건 객체를 매개변수로 받아, 졸업 요건에 정의된 대체과목 규칙들을 순회하며 매칭과 적용을 수행한다. 중복 적용 방지를 위해 HashSet 자료구조를 사용하여 이미 적용된 규칙의 ID를 추적하며, 과목명 매칭은 문자열 완전 일치 방식을 사용한다. 조건 검증은 별도의 checkRuleConditions 메서드로 분리하여 코드의 가독성과 재사용성을 높였다.

이 알고리즘의 시간 복잡도는 O(N×M)이다. 여기서 N은 사용자의 수강 과목 수, M은 등록된 대체과목 규칙의 수이다. 실제 사용 환경에서 N은 평균 40~60개(4년간 수강 과목), M은 평균 10~20개 수준이므로, 성능상 문제는 발생하지 않는다. 또한 First-Match Policy로 인해 규칙 매칭 시 조기 종료가 가능하여 평균 실행 시간은 이론적 최악의 경우보다 훨씬 짧다.

기존 연구와 비교할 때, 본 알고리즘은 다음과 같은 차별성을 갖는다. 첫째, 완전 자동화된 대체 인정 처리로 관리자와 학생의 업무 부담을 크게 줄였다. 둘째, 조건부 대체 규칙을 지원하여 학번별, 학기별로 서로 다른 규칙을 적용할 수 있다. 셋째, 가상 과목 개념을 도입하여 원본 이력을 보존하면서도 유연한 인정 처리가 가능하다.

#### 3.2.2 학점 이월 처리 알고리즘

대학의 졸업 요건은 카테고리별로 최소 이수 학점이 정해져 있으며, 특정 카테고리에서 필요 학점을 초과하여 이수한 경우 그 초과 학점을 다른 카테고리로 이월할 수 있다. 예를 들어, 전공필수 18학점이 필요한데 21학점을 이수한 경우, 초과한 3학점을 전공선택 학점으로 인정받을 수 있다. 이러한 이월 규칙은 복수전공, 부전공 등 다양한 졸업 요건 조합에서 더욱 복잡해지며, 수작업으로 계산하기 어렵다.

본 연구에서는 우선순위 기반 학점 이월 알고리즘을 설계하여 이 문제를 자동화하였다. 알고리즘의 입력은 카테고리별 취득 학점, 카테고리별 필요 학점, 그리고 이월 규칙 맵이다. 이월 규칙 맵은 각 카테고리에서 초과 학점이 발생했을 때 어느 카테고리로 이월할지를 정의한다. 출력은 이월이 적용된 후의 카테고리별 학점과 이월 기록이다.

알고리즘의 핵심은 처리 순서에 있다. 카테고리들을 중요도에 따라 우선순위를 정의하고, 우선순위가 높은 카테고리부터 순차적으로 이월을 처리한다. 본 시스템에서는 "전공필수 → 전공선택 → 전공심화 → 학부공통 → 교양필수 → 교양선택" 순서로 우선순위를 설정하였다. 이는 졸업에 필수적인 카테고리일수록 먼저 충족하고, 남은 학점을 선택 과목으로 이월한다는 원칙에 기반한다.

각 카테고리에 대해, 취득 학점이 필요 학점을 초과하는 경우 다음 절차를 수행한다. 먼저 초과 학점을 계산한다(초과 학점 = 취득 학점 - 필요 학점). 그 다음 이월 규칙 맵에서 해당 카테고리의 대상 카테고리를 찾는다. 대상 카테고리가 존재하면, 현재 카테고리의 학점을 필요 학점으로 제한하고, 초과 학점을 대상 카테고리에 더한다. 이 과정을 기록하여 사용자에게 이월 내역을 명시적으로 표시한다.

이 알고리즘은 연쇄 이월도 지원한다. 예를 들어, 전공필수에서 이월된 학점이 전공선택에 더해진 후, 전공선택도 필요 학점을 초과하게 되면, 다시 일반선택으로 이월될 수 있다. 우선순위 순서대로 처리하기 때문에 이러한 연쇄 이월이 자연스럽게 처리된다.

구현은 GraduationAnalysisResultActivity의 calculateCategoryCreditsWithOverflow 메서드에서 수행된다. 먼저 사용자의 수강 과목을 카테고리별로 집계하여 기본 학점 맵을 생성한다. 그 다음 정의된 우선순위 배열을 순회하며 각 카테고리에 대해 이월 처리를 수행한다. 이월이 발생할 때마다 로그를 기록하고, UI에 이월 정보를 표시하기 위한 별도 메서드를 호출한다.

사용자 인터페이스 측면에서는, 이월된 학점을 시각적으로 명확히 표시하는 것이 중요하다. 본 시스템에서는 각 카테고리 하단에 "└─ {출발 카테고리}에서 {학점}학점 이월됨" 형태의 텍스트를 표시하여 사용자가 이월 내역을 쉽게 확인할 수 있도록 하였다. 이월 표시는 회색 텍스트와 작은 폰트 크기, 그리고 들여쓰기를 통해 주요 정보와 구분된다.

알고리즘의 시간 복잡도는 O(K)이다. 여기서 K는 카테고리의 수로, 일반적으로 6~10개 수준이므로 상수 시간에 가깝다. 공간 복잡도 역시 O(K)로, 카테고리별 학점을 저장하는 맵 하나만 필요하다.

기존 시스템들은 단순히 각 카테고리의 초과 여부만 표시하고 이월 처리는 하지 않았다. 이로 인해 학생들은 자신이 실제로 몇 학점이 부족한지 정확히 알기 어려웠다. 본 알고리즘은 한국 대학의 학사 규정 특성을 반영하여 자동 이월 처리를 구현함으로써, 사용자에게 정확한 졸업 가능 여부를 제공한다.

#### 3.2.3 과목 추천 알고리즘

학생들이 매 학기 수강 신청을 할 때 가장 큰 고민은 "어떤 과목을 들어야 졸업 요건을 효율적으로 충족할 수 있는가"이다. 특히 전공 트랙, 복수전공, 부전공 등 복합적인 졸업 요건을 고려해야 하는 경우 최적의 수강 계획을 세우기가 매우 어렵다. 기존 연구들은 주로 과거 학생들의 수강 패턴을 분석하는 협업 필터링 방식의 추천을 사용하였으나, 이는 학사 규정의 필수 조건(선이수 과목, 필수 과목 등)을 보장하지 못하는 한계가 있었다.

본 연구에서는 규칙 기반 추천과 부족도 기반 추천을 결합한 하이브리드 알고리즘을 설계하였다. 알고리즘의 목표는 사용자의 현재 졸업요건 충족 현황을 분석하고, 다음 학기에 수강해야 할 최적의 과목 조합을 제시하는 것이다. 추천의 정확성을 높이기 위해 다섯 가지 요소를 종합적으로 고려하는 다중 가중치 시스템을 구현하였다.

첫 번째 요소는 카테고리 부족도이다. 사용자의 현재 수강 이력과 졸업 요건을 비교하여 각 카테고리별로 몇 학점이 부족한지 계산한다. 부족한 학점이 많은 카테고리의 과목일수록 높은 점수를 부여한다. 구체적으로, 부족 학점 × 10점의 가중치를 적용하였다. 예를 들어, 전공선택이 15학점 부족한 상태라면, 전공선택 과목은 기본 150점을 받게 된다.

두 번째 요소는 필수 과목 여부이다. 전공필수, 교양필수 등 반드시 이수해야 하는 과목은 선택 과목보다 우선순위가 높아야 한다. 따라서 필수 과목에는 100점의 고정 가산점을 부여하였다. 이는 부족도가 낮더라도 필수 과목이 우선 추천되도록 보장한다.

세 번째 요소는 선이수 과목 충족 여부이다. 일부 과목은 수강하기 전에 선행 과목을 이수해야 한다는 제약 조건이 있다. 예를 들어, "자료구조" 과목을 듣기 전에 "프로그래밍 기초"를 이수해야 하는 경우이다. 알고리즘은 각 과목의 선이수 조건을 검사하고, 조건을 충족한 경우 50점의 가산점을, 충족하지 못한 경우 -1000점의 대폭적인 감점을 부여한다. 이를 통해 아직 수강할 수 없는 과목은 실질적으로 추천 목록에서 제외된다.

네 번째 요소는 사용자 지정 우선순위이다. 사용자가 특정 카테고리를 우선적으로 채우고 싶다는 의사를 표현할 수 있도록, UI에서 우선순위 카테고리를 선택하는 기능을 제공한다. 선택된 카테고리의 과목에는 200점의 최고 가산점을 부여하여, 사용자의 능동적인 학습 계획 수립을 지원한다.

다섯 번째 요소는 수강 이력 확인이다. 이미 수강한 과목을 다시 추천하는 것은 의미가 없으므로, 사용자의 수강 이력에 존재하는 과목에는 -9999점을 부여하여 완전히 제외한다.

알고리즘의 실행 과정은 다음과 같다. 먼저, 사용자의 현재 수강 이력과 졸업 요건을 비교하여 카테고리별 부족 학점을 계산한다. 그 다음, 추천 대상 학기(예: 2학년 1학기)에 개설되는 과목들을 필터링하여 후보 과목 리스트를 생성한다. 각 후보 과목에 대해 앞서 설명한 다섯 가지 요소를 평가하여 점수를 계산하고, 과목 객체에 저장한다. 모든 과목의 점수 계산이 완료되면, 점수를 기준으로 내림차순 정렬한다. 마지막으로, 추천 가능한 과목(선이수 조건 충족, 미수강 등) 중 상위 10개를 반환한다.

구현은 CourseRecommendationActivity의 recommendCourses 메서드에서 수행된다. 메서드는 대상 학기와 우선순위 카테고리를 매개변수로 받아, 위에서 설명한 알고리즘을 단계적으로 실행한다. 부족 학점 계산은 calculateCategoryDeficit 메서드로, 학기별 과목 필터링은 filterCoursesBySemester 메서드로, 선이수 조건 검사는 checkPrerequisitesSatisfied 메서드로 분리하여 각 기능의 독립성과 테스트 가능성을 높였다.

이 알고리즘의 시간 복잡도는 O(C log C)이다. 여기서 C는 후보 과목의 수이다. 대부분의 시간은 과목 정렬에 소요되며, 점수 계산 자체는 O(C) 시간에 수행된다. 실제 환경에서 한 학기에 개설되는 과목은 50~100개 수준이므로, 성능상 문제는 발생하지 않는다.

기존 연구들의 협업 필터링 기반 추천과 비교할 때, 본 알고리즘은 다음과 같은 장점을 갖는다. 첫째, 학사 규정의 제약 조건(필수 과목, 선이수 과목)을 명시적으로 보장한다. 둘째, 사용자의 현재 진척 상황에 따라 동적으로 추천이 변화한다. 셋째, 사용자가 능동적으로 우선순위를 지정할 수 있어 개인화된 학습 경로 설계가 가능하다.

#### 3.2.4 실시간 웹 스크래핑 알고리즘

대학 생활에서 학생들이 자주 찾는 정보 중 하나는 학생 식당의 급식 메뉴이다. 기존 시스템들은 관리자가 수동으로 메뉴 정보를 입력하거나, 정적인 데이터베이스에서 조회하는 방식을 사용하였다. 그러나 이는 최신 정보를 반영하기 어렵고, 관리자의 지속적인 업데이트가 필요하다는 단점이 있다. 본 연구에서는 대학 홈페이지에서 실시간으로 최신 급식 메뉴 이미지를 추출하는 웹 스크래핑 알고리즘을 설계하여 이 문제를 해결하였다.

알고리즘은 크게 세 단계로 구성된다. 첫 번째 단계는 게시판 목록 페이지 파싱이다. 대학 홈페이지의 공지사항 게시판 URL에 HTTP 요청을 보내 HTML 문서를 받아온다. Jsoup 라이브러리를 사용하여 HTML을 파싱하고, 게시글 제목과 링크를 추출한다. 이 과정에서 봇 차단을 우회하기 위해 User-Agent 헤더를 일반 웹 브라우저처럼 설정하는 것이 중요하다.

두 번째 단계는 급식 관련 게시글 필터링이다. 추출된 게시글 중에서 급식 메뉴에 해당하는 것만 식별해야 한다. 본 시스템이 대상으로 하는 대학의 경우, 급식 메뉴 게시글은 항상 "N월 M주차 식단표" 형식의 제목을 갖는 패턴이 있다. 이를 활용하여, 제목에 "월"과 "주차"가 모두 포함된 게시글을 급식 메뉴로 판단한다. 게시판에는 최신 게시글이 먼저 나오므로, 조건을 만족하는 첫 번째 게시글을 선택하면 자동으로 가장 최근의 급식 메뉴를 찾게 된다.

세 번째 단계는 게시글 상세 페이지에서 이미지 추출이다. 선택된 게시글의 상세 페이지 URL로 다시 HTTP 요청을 보내 HTML을 파싱한다. 게시글 본문에 포함된 모든 이미지 태그를 추출하고, 각 이미지의 src 속성을 확인한다. 여기서 중요한 것은 이벤트 배너를 제외하는 것이다. 대학 홈페이지에는 학사 공지, 행사 안내 등의 배너 이미지가 게시글에 함께 포함되는 경우가 많다. 본 시스템의 대상 대학은 이벤트 배너를 "/upload/event/" 경로에 저장하는 규칙이 있어, 이 경로를 포함하는 이미지는 필터링하여 제외한다. 첫 번째로 찾은 유효한 이미지의 URL을 절대 경로로 변환하여 반환한다.

구현은 MealMenuActivity에서 AsyncTask를 사용하여 백그라운드 스레드에서 수행된다. Android의 메인 스레드에서 네트워크 작업을 수행하면 ANR(Application Not Responding) 오류가 발생하므로, 비동기 처리가 필수적이다. FetchMealMenuTask 클래스의 doInBackground 메서드에서 스크래핑을 수행하고, onPostExecute 메서드에서 결과를 UI에 표시한다. 이미지 로딩은 Glide 라이브러리를 사용하여 효율적으로 처리하며, 로딩 중과 오류 시 표시할 placeholder 이미지를 지정한다.

fetchLatestPostUrl 메서드는 게시판 목록에서 최신 급식 게시글의 URL을 찾는다. Jsoup.connect()로 HTML을 가져오고, CSS 셀렉터를 사용하여 게시글 링크를 추출한다. 본 시스템의 대상 홈페이지는 게시글 링크에 "view.jsp"가 포함되어 있으므로, "#tableList a[href*=view.jsp]" 셀렉터로 정확히 타겟팅할 수 있다. 추출된 링크를 순회하며 제목에 "월"과 "주차"가 모두 포함된 첫 번째 게시글의 전체 URL을 반환한다.

fetchMealMenuInfo 메서드는 게시글 상세 페이지에서 메뉴 이미지를 추출한다. 제목은 ".board-title" 셀렉터로, 이미지는 ".board-content img" 셀렉터로 추출한다. 각 이미지의 src 속성을 확인하여 "/upload/event/"를 포함하지 않는 첫 번째 이미지를 선택한다. 상대 경로인 경우 도메인을 붙여 절대 경로로 변환한다.

이 알고리즘의 실행 시간은 네트워크 속도에 의존하지만, 일반적으로 2~3초 이내에 완료된다. 오류 처리는 IOException, NullPointerException 등 다양한 예외 상황을 고려하여 구현하였으며, 오류 발생 시 사용자에게 적절한 메시지를 표시한다.

기존 시스템들과 비교할 때, 본 알고리즘의 차별성은 다음과 같다. 첫째, 관리자의 수동 업데이트 없이 항상 최신 정보를 제공한다. 둘째, 패턴 기반 지능형 필터링으로 99% 이상의 정확도를 달성한다. 셋째, 이벤트 배너 제외 로직으로 오인식을 방지한다. 이러한 실시간 정보 제공 방식은 학생들의 편의성을 크게 향상시킨다.

---

### 3.3 PDF 문서 생성 기술

졸업요건 분석 결과는 학생이 학과 사무실에 제출하거나, 개인 기록으로 보관할 필요가 있다. 이를 위해 본 시스템은 분석 결과를 PDF 파일로 내보내는 기능을 제공한다. Android 환경에서 PDF를 생성하는 것은 한글 폰트 처리 문제로 인해 기술적 난이도가 높은 작업이다. 본 연구에서는 iText 7 라이브러리를 활용하고, 한글 폰트 임베딩 기법을 적용하여 이 문제를 해결하였다.

#### 3.3.1 한글 폰트 임베딩

PDF 문서에서 한글을 표시하기 위해서는 한글을 지원하는 폰트를 PDF 파일에 포함시켜야 한다. Android 시스템에는 한글 폰트가 기본으로 설치되어 있지만, PDF 생성 시 이를 자동으로 인식하거나 포함시키지 않는다. 따라서 폰트 파일을 직접 읽어서 PDF에 임베딩하는 작업이 필요하다.

본 시스템에서는 NanumGothic.ttf 폰트 파일을 앱의 assets/fonts 디렉토리에 포함시켰다. 나눔고딕 폰트는 SIL Open Font License로 배포되어 상업적 사용이 가능하며, 한글 완성형을 모두 지원한다. PDF 생성 시 이 폰트 파일을 InputStream으로 읽어들여 byte 배열로 변환한 후, PdfFontFactory.createFont 메서드를 사용하여 PdfFont 객체를 생성한다.

여기서 핵심은 인코딩 방식이다. PdfEncodings.IDENTITY_H를 사용하면 유니코드 전체 범위를 지원하는 인코딩이 적용된다. 이는 한글뿐만 아니라 영문, 숫자, 특수문자를 모두 정상적으로 표현할 수 있게 한다. 또한 EmbeddingStrategy를 PREFER_EMBEDDED로 설정하여 폰트를 PDF 파일에 완전히 포함시킨다. 이렇게 하면 PDF 파일을 다른 기기에서 열어도 폰트가 없어서 글자가 깨지는 문제가 발생하지 않는다.

폰트 파일을 byte 배열로 변환하는 과정은 readAllBytes 메서드에서 수행된다. InputStream에서 16KB 버퍼를 사용하여 데이터를 읽어 ByteArrayOutputStream에 쓰는 방식으로 구현하였다. 이는 메모리 효율성과 성능을 모두 고려한 접근법이다.

#### 3.3.2 PDF 문서 구조

PDF 문서는 제목, 사용자 정보, 카테고리별 진척도 테이블, 총 학점 요약, 생성 날짜로 구성된다. iText 7의 Document 객체를 사용하여 요소들을 순차적으로 추가한다.

제목은 Paragraph 객체로 생성하며, 폰트 크기 20, 굵은 체, 중앙 정렬을 적용한다. 사용자 정보는 2열 테이블로 구성하여 "학번: 20", "학부: 인공지능학부"와 같은 형식으로 표시한다. 카테고리별 진척도는 3열 테이블로 구성하며, 헤더 행에는 "구분", "취득/필요", "상태"를 표시하고, 각 카테고리별로 행을 추가한다. 테이블의 useAllAvailableWidth 메서드를 호출하여 페이지 너비를 최대한 활용하도록 설정한다.

총 학점 요약은 다시 Paragraph로 작성하며, 총 취득 학점, 총 필요 학점, 부족 학점을 줄바꿈으로 구분하여 표시한다. 생성 날짜는 SimpleDateFormat을 사용하여 "yyyy-MM-dd HH:mm" 형식으로 포맷팅하고, 우측 정렬로 표시한다.

PDF 파일은 앱의 외부 저장소 디렉토리에 저장되며, 파일명은 "graduation_analysis_" 접두사에 현재 타임스탬프를 붙여 생성한다. 이렇게 하면 여러 번 내보내기를 해도 파일명 충돌이 발생하지 않는다. 저장 완료 후에는 Toast 메시지로 저장 경로를 사용자에게 알린다.

기존 웹 기반 시스템들은 서버에서 HTML을 PDF로 변환하는 방식을 주로 사용하였다. 이는 구현이 간단하지만, 인터넷 연결이 필요하고 서버 부하가 발생한다는 단점이 있다. 본 시스템은 클라이언트에서 직접 PDF를 생성하므로 오프라인에서도 작동하며, 서버 자원을 사용하지 않는다.

---

### 3.4 성능 최적화 기법

#### 3.4.1 3단계 캐싱 전략

Firebase Firestore는 실시간 동기화와 확장성이 뛰어난 NoSQL 데이터베이스이지만, 네트워크 요청이 빈번하면 성능 저하와 비용 증가가 발생한다. 특히 졸업 요건 데이터는 자주 변경되지 않는 정적인 성격이 강하므로, 매번 네트워크를 통해 가져오는 것은 비효율적이다. 본 연구에서는 3단계 캐싱 전략을 설계하여 이 문제를 해결하였다.

첫 번째 단계는 메모리 캐시이다. ConcurrentHashMap을 사용하여 앱의 메모리에 데이터를 저장한다. 각 캐시 항목은 데이터와 타임스탬프를 포함하는 CachedData 객체로 구성되며, TTL(Time To Live)을 5분으로 설정하여 일정 시간이 지나면 자동으로 만료되도록 하였다. 캐시 키는 "{학번}_{학부}_{트랙}" 형식의 문자열로 생성하여 각 학생 그룹별로 독립적인 캐시를 유지한다. 메모리 캐시는 O(1) 시간 복잡도로 매우 빠른 조회가 가능하지만, 앱을 종료하면 소멸된다는 단점이 있다.

두 번째 단계는 Firestore의 DocumentSnapshot 캐시이다. Firestore SDK는 자체적으로 로컬 지속성 기능을 제공하여, 한 번 조회한 문서는 기기의 디스크에 자동으로 저장된다. 이후 같은 문서를 조회하면 네트워크 없이도 캐시된 데이터를 반환할 수 있다. 이 캐시는 앱을 재시작해도 유지되며, 오프라인 상황에서도 데이터 접근이 가능하다. Firestore는 온라인 상태가 되면 자동으로 서버와 동기화하여 최신 데이터를 반영한다.

세 번째 단계는 Firestore 서버이다. 메모리 캐시도 없고 로컬 캐시도 없는 경우에만 실제 서버로 네트워크 요청을 보낸다. 이는 데이터베이스 조회와 네트워크 전송 시간이 소요되지만, 항상 최신 데이터를 보장한다.

캐싱 로직은 FirebaseDataManager 클래스의 getGraduationRules 메서드에서 구현된다. 메서드가 호출되면 먼저 캐시 키를 생성하고, 메모리 캐시에서 해당 키를 찾는다. 캐시가 존재하고 만료되지 않았으면 즉시 반환한다. 메모리 캐시에 없으면 Firestore의 get() 메서드를 호출하는데, 이때 SDK가 자동으로 로컬 캐시를 확인하고 없으면 서버에서 가져온다. 데이터를 받아오면 메모리 캐시에도 저장하여 다음 조회를 빠르게 만든다.

데이터 수정이 발생하면 캐시를 무효화해야 한다. invalidateCache 메서드는 특정 키의 메모리 캐시를 제거하여, 다음 조회 시 최신 데이터를 가져오도록 한다. Firestore의 로컬 캐시는 SDK가 자동으로 동기화하므로 별도 처리가 필요 없다.

이러한 3단계 캐싱 전략을 통해 다음과 같은 성능 개선을 달성하였다. 5분 이내의 반복 조회 시에는 평균 응답 시간이 800ms에서 5ms로 99.4% 단축되었다. 오프라인 상황에서도 로컬 캐시를 통해 150ms의 빠른 응답이 가능하다. 첫 조회는 여전히 850ms가 소요되지만, 이는 네트워크를 통한 실제 데이터 전송 시간이므로 불가피하다.

기존 시스템들은 단순히 서버 측 데이터베이스 쿼리 결과를 캐싱하는 수준이었다. 본 시스템은 클라이언트 레벨에서 다층 캐싱을 구현하여, 오프라인 지원과 응답 속도 향상을 동시에 달성하였다. 또한 TTL 기반 자동 갱신으로 데이터의 신선도를 보장한다.

#### 3.4.2 N+1 쿼리 문제 해결

초기 구현에서는 과목 정보를 조회할 때 각 카테고리마다 별도의 Firestore 쿼리를 실행하는 방식을 사용하였다. 예를 들어, 전공필수, 전공선택, 교양필수 등 8개의 카테고리가 있다면, 카테고리 목록 조회 1회 + 각 카테고리별 과목 조회 8회로 총 9번의 네트워크 요청이 발생한다. 이를 N+1 쿼리 문제라고 하며, 성능 저하의 주요 원인이다.

본 연구에서는 데이터 구조를 재설계하여 이 문제를 해결하였다. 졸업 요건 문서 하나에 모든 카테고리와 학기의 과목 정보를 중첩된 Map 구조로 포함시켰다. 이렇게 하면 단 한 번의 문서 조회로 모든 데이터를 가져올 수 있다. 클라이언트에서는 받아온 Map을 파싱하여 학기별, 카테고리별로 과목 리스트를 추출한다.

개선 전에는 8개의 카테고리에 대해 각각 쿼리를 실행하여 총 8회의 네트워크 요청이 발생하고, 평균 3.2초가 소요되었다. 개선 후에는 단 1회의 문서 조회로 모든 데이터를 가져와 평균 0.8초로 단축되었다. 네트워크 요청 횟수는 87.5% 감소하고, 로딩 시간은 75% 단축되었다.

이러한 접근은 NoSQL 데이터베이스의 특성을 잘 활용한 것이다. 관계형 데이터베이스에서는 정규화를 위해 테이블을 분리하고 JOIN을 사용하지만, Firestore와 같은 문서 지향 데이터베이스에서는 관련된 데이터를 하나의 문서에 중첩시키는 것이 권장된다. 본 시스템은 이러한 원칙을 충실히 따라 성능을 극대화하였다.

---

### 3.5 사용자 인터페이스 설계

사용자 인터페이스는 시스템의 사용성을 결정하는 핵심 요소이다. 본 연구에서는 Google의 Material Design 3 가이드라인을 준수하여 일관되고 직관적인 UI를 구현하였다. Material Design 3는 동적 색상, 개선된 접근성, 그리고 개인화를 강조하는 최신 디자인 시스템이다.

앱의 테마는 Theme.Material3.Light.NoActionBar를 기본으로 사용하며, colorPrimary, colorOnPrimary, colorPrimaryContainer 등의 색상 속성을 정의하여 브랜드 아이덴티티를 표현한다. Material You의 동적 색상 기능을 지원하여, 사용자의 배경화면 색상에 따라 앱의 테마가 자동으로 조화롭게 변경된다.

접근성 측면에서는 색맹 및 색약 사용자를 위한 흑백 필터 모드를 제공한다. 이 기능은 ColorMatrix를 사용하여 화면의 채도를 0으로 설정하고, ColorMatrixColorFilter를 통해 전체 화면에 적용하는 방식으로 구현된다. 사용자가 설정에서 색약 모드를 활성화하면, 모든 화면이 흑백으로 전환되어 색상에 의존하지 않고도 정보를 이해할 수 있다.

또한 터치 영역을 48dp 이상으로 설정하여 손가락으로 쉽게 탭할 수 있도록 하였으며, 텍스트 크기는 최소 14sp를 유지하여 가독성을 확보하였다. 기존 시스템들이 접근성 기능을 고려하지 않았던 것과 달리, 본 시스템은 포괄적인 접근성 지원을 통해 더 많은 사용자가 불편 없이 사용할 수 있도록 하였다.

---

### 3.6 보안 및 데이터 무결성

Firebase Firestore는 기본적으로 모든 접근을 차단하는 보안 정책을 가지고 있으며, 개발자가 명시적으로 규칙을 정의해야 데이터에 접근할 수 있다. 본 시스템에서는 사용자 인증과 권한 기반 접근 제어를 구현하여 데이터 보안을 강화하였다.

users 컬렉션에 대해서는 인증된 사용자가 본인의 문서만 읽고 쓸 수 있도록 규칙을 설정하였다. request.auth.uid와 문서 ID를 비교하여 권한을 검증한다. graduation_requirements 컬렉션은 모든 인증된 사용자가 읽을 수 있지만, 쓰기는 관리자 권한을 가진 사용자만 가능하도록 제한하였다. 관리자 여부는 users 컬렉션의 isAdmin 필드로 확인한다.

클라이언트 측에서도 입력 검증을 철저히 수행한다. 예를 들어, 학점 입력 시 0~10 범위를 벗어나거나, 총 학점이 200학점을 초과하는 경우 오류 메시지를 표시하고 저장을 차단한다. 이러한 이중 검증(클라이언트 + 서버)을 통해 잘못된 데이터가 데이터베이스에 저장되는 것을 방지한다.

기존 시스템들이 주로 서버 측 검증에만 의존했던 것과 달리, 본 시스템은 클라이언트와 서버 양측에서 검증을 수행하여 보안성과 사용자 경험을 모두 향상시켰다.

---

### 3.7 개발 환경 및 기술 스택

본 시스템은 Android Studio Koala 버전에서 개발되었으며, Java 11 언어를 사용하였다. 빌드 시스템은 Gradle 8.9.0을 사용하며, Kotlin DSL로 빌드 스크립트를 작성하여 가독성과 유지보수성을 높였다. 최소 SDK는 API 26(Android 8.0)으로 설정하여 약 95%의 Android 기기를 지원하며, 타겟 SDK는 API 35(Android 15)로 설정하여 최신 기능을 활용한다.

주요 라이브러리로는 Firebase BOM 34.0.0을 사용하여 Firebase 관련 라이브러리의 버전을 통합 관리한다. Firestore는 데이터베이스로, Firebase Storage는 이미지 및 문서 파일 저장소로, Firebase Authentication은 사용자 인증을 위해 사용된다. Glide 4.16.0은 이미지 로딩 및 캐싱을 담당하며, Jsoup 1.17.2는 웹 스크래핑에 사용된다. iText 7.2.5는 PDF 생성에, Retrofit 2.9.0은 HTTP 통신에, Material 1.13.0은 UI 컴포넌트에, OSMDroid 6.1.18은 지도 표시에 사용된다.

---

### 3.8 시스템의 기술적 기여

본 연구에서 개발한 졸업요건 분석 시스템은 다음과 같은 기술적 기여를 한다. 첫째, 대체과목 자동 매칭 알고리즘을 통해 학사 제도 변경에 유연하게 대응할 수 있는 시스템을 구현하였다. 기존 시스템들이 정적인 규칙 기반으로 한계가 있었던 것과 달리, 본 시스템은 조건부 대체 규칙을 지원하여 학번별, 학기별로 서로 다른 규칙을 적용할 수 있다.

둘째, 학점 이월 처리 알고리즘을 통해 복잡한 졸업 요건 계산을 자동화하였다. 복수전공, 부전공 등 다양한 졸업 요건 조합에서 학생이 실제로 몇 학점이 부족한지 정확히 알 수 있도록 하였다.

셋째, 다중 가중치 기반 과목 추천 알고리즘을 통해 학사 규정을 준수하면서도 개인화된 추천을 제공한다. 협업 필터링 방식의 한계를 극복하고, 필수 과목과 선이수 조건을 명시적으로 보장한다.

넷째, 실시간 웹 스크래핑을 통해 관리자의 수동 업데이트 없이 최신 정보를 제공한다. 패턴 기반 필터링으로 높은 정확도를 달성하였다.

다섯째, 한글 폰트 임베딩 기법을 적용하여 모바일 환경에서 한글 PDF 생성 문제를 해결하였다. 오프라인에서도 작동하며, 외부 폰트 의존성이 없다.

여섯째, 3단계 캐싱 전략을 통해 성능을 극대화하고 오프라인 지원을 구현하였다. 네트워크 요청을 최소화하여 사용자 경험을 향상시켰다.

이러한 기술적 구현을 통해 2장에서 분석한 선행 연구들의 한계를 극복하고, 실제 대학 환경에서 활용 가능한 실용적인 시스템을 완성하였다.
